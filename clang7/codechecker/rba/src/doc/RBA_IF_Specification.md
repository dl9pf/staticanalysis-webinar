# RBA Interface Specification



### Version 1.0



### 2020/02/28



<div style="page-break-after:always"></div>

### Table of Contents

[**1. Purpose of this document**](#anchor0)

[**2. Arbitration Policy Type class**](#anchor1)  
2.1. Definition name  
2.2. Overview  
2.3. Class member

[**3. Arbitrator Logic class**](#anchor2)  
3.1. Definition name  
3.2. Overview  
3.3. Class member

[**4. Area class**](#anchor3)  
4.1. Definition name  
4.2. Overview  
4.3. Class member

[**5. Base Point class**](#anchor4)  
5.1. Definition name  
5.2. Overview  
5.3. Class member

[**6. Content Loser Type class**](#anchor5)  
6.1. Definition name  
6.2. Overview  
6.3. Class member

[**7. Display class**](#anchor6)  
7.1. Definition name  
7.2. Overview  
7.3. Class member

[**8. Json Parser class**](#anchor7)  
8.1. Definition name  
8.2. Overview  
8.3. Class member

[**9. Model class**](#anchor8)  
9.1. Definition name  
9.2. Overview  
9.3. Class member

[**10. Position Container class**](#anchor9)  
10.1. Definition name  
10.2. Overview  
10.3. Class member

[**11. Result class**](#anchor10)  
11.1. Definition name  
11.2. Overview  
11.3. Class member

[**12. Arbitration Result Status Type class**](#anchor11)  
12.1. Definition name  
12.2. Overview  
12.3. Class member

[**13. Scene class**](#anchor12)  
13.1. Definition name  
13.2. Overview  
13.3. Class member

[**14. Size class**](#anchor13)  
14.1. Definition name  
14.2. Overview  
14.3. Class member

[**15. Sound Content class**](#anchor14)  
15.1. Definition name  
15.2. Overview  
15.3. Class member

[**16. Sound Content State class**](#anchor15)  
16.1. Definition name  
16.2. Overview  
16.3. Class member

[**17. View Action class**](#anchor16)  
17.1. Definition name  
17.2. Overview  
17.3. Class member

[**18. View Action Type class**](#anchor17)  
18.1. Definition name  
18.2. Overview  
18.3. Class member

[**19. View Content class**](#anchor18)  
19.1. Definition name  
19.2. Overview  
19.3. Class member

[**20. View Content State class**](#anchor19)  
20.1. Definition name  
20.2. Overview  
20.3. Class member

[**21. Zone class**](#anchor20)  
21.1. Definition name  
21.2. Overview  
21.3. Class member

<div style="page-break-after:always"></div>
<a id="anchor0"></a>

# **1. Purpose**

<span style="font-size:130%;">This document describes the interface specifications for RBA(Rule -based Arbitration).  
Chapter 2 explains each interface.</span>

<div style="page-break-after:always"></div>
<a id="anchor1"></a>

# **2. Arbitration Policy Type class**

<span style="font-size:130%;">**2.1. Definition name**</span>  
<span style="font-size:130%;">RBAArbitrationPolicy : std::uint8_t</span>

<span style="font-size:130%;">**2.2. Overview**</span>  
<span style="font-size:130%;">Type of arbitration policy.</span>

<span style="font-size:130%;">**2.3. Class member**</span>  
**DEFAULT**  
@brief  
Same as PRIORITY_LAST_COME_FIRST.

**FIRST_COME_FIRST**  
@brief  
First Come First Arbitration.

@details  
Give priority to first come request.

**LAST_COME_FIRST**  
@brief  
Last Come First Arbitration.

@details  
Give priority to last come request.

**PRIORITY_FIRST_COME_FIRST**  
@brief  
Priority and First Come First Arbitration.

@details  
Follow the Priority of Contents.   
If same priority then give priority to first come request.

**PRIORITY_LAST_COME_FIRST**  
@brief  
Priority and Last Come First Arbitration.

@details  
Follow the Priority of Contents.  
If same priority then give priority to last come request.

<div style="page-break-after:always"></div>
<a id="anchor2"></a>

# **3. Arbitrator Logic class**

<span style="font-size:130%;">**3.1. Definition name**</span>  
<span style="font-size:130%;">DLL_EXPORT RBAArbitrator</span>

<span style="font-size:130%;">**3.2. Overview**</span>  
<span style="font-size:130%;">An object that performs arbitration processing based on rules generated from a model.  
Set the model generated using rba::RBAJsonParser in the constructor.</span>

<span style="font-size:130%;">**3.3. Class member**</span>  
**RBAArbitrator(RBAModel\* newModel);**  
@brief  
Arbitrator logic constructor.

@param newModel  
Processing model.  
The model is generated by rba::RBAJsonParser.

**virtual ~RBAArbitrator() noexcept;**  
@brief  
Arbitrator logic destructor.

**void setModel(RBAModel\* newModel);**  
@brief  
Sets the model for arbitration.  
The model is generated by rba::RBAJsonParser.

@param newModel  
The model for arbitration.

@details  
Replace the model with newModel.  
An arbitrator has only one model at all times.  
Model can be generated by using rba::RBAJsonParser. nullptr can not be set.

**const RBAModel\* getModel() const;**  
@brief  
Returns the model for arbitration.

@return  
The model for arbitration.

@details  
Because the arbitrator always has a model, this API never returns nullptr.

**void initialize(std::list\<std::string>& contexts);**  
@brief  
Set initial requirements of contents and scenes.

@param contexts  
Context list of contents and scenes requests.  
Following is the structure of context name.  
<CONTENT_NAME> / <STATE_NAME>

Example of context name:  
TEL/Calling  
TPMS/NORMAL  
AutoDriveScene

You can omit "/ <STATE_NAME>" if content has only one state.

@details  
After arbitrator creation or calling clearArbitration(), you can set initial state of contents and scenes for first arbitration.  
This API does not execute arbitration.  
The information of arbitration result will be empty.  
Don't call this API after starting arbitration until calling clearArbitration().

**Example**  
```cpp
RBAJsonParser parser;  
rba::RBAModel* model = parser.parse(JSONFILE_PATH);  
rba::RBAArbitrator* arb = new rba::RBAArbitrator(model);
std::list\<std::string> defaultContents = {  
	"CONTENT_A/NORMAL",  
	"CONTENT_B/NORMAL",  
	"CONTENT_C/NORMAL",  
	"CONTENT_D/NORMAL",  
};  
arb->initialize(defaultContents);  
std::unique_ptr\<RBAResult> result = arb->execute();  
```

**std::unique_ptr\<RBAResult> execute(const std::string& contextName="", bool require=true);**  
@brief  
Executes arbitration with one requirement.

@param contextName  
Context string of arbitration request.  
Display request or sound request :   
"<CONTENT_NAME>/<STATE_NAME>"
If the content has only one state, the \<STATE> can be omitted.  
Scene request :  
"<SCENE_NAME>"

@param require  
true : request displaying / outputting content or scene on (default)  
false : withdraw a request or scene off.

@return  
The result of arbitration.

@details  
Execute Arbitration with one requirement of a content or scene without properties.  
The arbitration result as the return value will be generated at every arbitration and will not be changed by another arbitration.  
Context indicates a content state or a scene.  
If the content or scene is not defined in the model, the arbitration will not executed and the state of the arbitration result will be UNKNWON_CONTENT_STATE.  
In this case, other property values are undefined.  
If the context is empty, this API just execute arbitration.

**Exapmle**  
```cpp
RBAJsonParser parser;  
rba::RBAModel* model = parser.parse(JSONFILE_PATH);  
rba::RBAArbitrator* arb = new rba::RBAArbitrator(model);  
std::unique_ptr\<RBAResult> result = arb->execute("CONTENT_A/NORMAL", true);

if (result->getStatusType() != rba::RBAResultStatusType::SUCCESS) {  
	std::cout << "ERROR: Unknown context" << std::endl;  
}  
```

**std::unique_ptr\<RBAResult> execute(std::list\<std::string>& contexts, bool require=true);**  
@brief  
Executes arbitration with multiple requirements.

@param contexts  
List of contexts.

@param require  
true : request displaying / outputting content or scene on (default)  
false : withdraw a request or scene off.

@return  
The result of arbitration.

@details
Execute Arbitration with multiple requirements of contents or scenes.  
Contents and Scenes can be mixed in the list.  
Display / Outputting request and withdraw request, scene on and scene off request can not be mixed.  
The arbitration result as the return value will be generated at every arbitration and will not be changed by another arbitration.  
Context indicates a content state or a scene.  
If the content or scene is not defined in the model, the arbitration will not executed and the state of the arbitration result will be UNKNWON_CONTENT_STATE.  
In this case, other property values are undefined.  
If the context is empty, this API just execute arbitration.  
Request order is the with the list. Beginning of the list will be treated as the first coming request.

**Exapmle**  
```cpp
RBAJsonParser parser;  
rba::RBAModel* model = parser.parse(JSONFILE_PATH);  
rba::RBAArbitrator* arb = new rba::RBAArbitrator(model);  
std::list\<std::string> contents = {  
	"CONTENT_A/NORMAL",  
	"CONTENT_B/NORMAL",  
	"CONTENT_C/NORMAL",  
	"CONTENT_D/NORMAL",  
};  
std::unique_ptr\<RBAResult> result = arb->execute(contents, true);

if (result->getStatusType() != rba::RBAResultStatusType::SUCCESS) {  
	std::cout << "ERROR: Unknown context" << std::endl;  
}  
```

**std::unique_ptr\<RBAResult> execute(const std::string& sceneName, std::list\<std::pair\<std::string,std::int32_t>>& properties);**  
@brief  
Executes arbitration with a requirement of scene and scene properties.  

@param sceneName  
The Scene name of arbitration reauest.

@param properties  
The list of pairs of property name and value.

@return  
The result of arbitration.

@details  
Sets the scene indicated by sceneName to the property specified by properties, and execute arbitration processing.  
If sceneName is empty, this API just execute arbitration.  
If the required scene is not defined in the model, the arbitration will not executed and the state of the arbitration result will be UNKNWON_CONTENT_STATE.  
Even If there is a property not defined in the model, the arbitration will be executed.

@note  
You cannot set scene off and property at the same time, by this API.  
Use setScene() to set scene off and properties,  and then call execute(const std::string&,bool) without specifying arguments.  
Or Use setScene() to set properties, and then call execute(scene name,false).

**Example**  
```cpp
RBAJsonParser parser;  
rba::RBAModel* model = parser.parse(JSONFILE_PATH);  
rba::RBAArbitrator* arb = new rba::RBAArbitrator(model);  
std::list<std::pair<std::string, std::int32_t>> properties;  
properties.push_back(std::make_pair("Prop1", 10));  
properties.push_back(std::make_pair("Prop2", 20));  
std::unique_ptr<RBAResult> result = arb->execute("Scene1", properties);

if (result->getStatusType() != rba::RBAResultStatusType::SUCCESS) {  
	std::cout << "ERROR: Unknown context" << std::endl;  
}  
```

**std::unique_ptr\<RBAResult> setResultContentState(const std::string& allocatableName, const std::string& contextName);**  
@brief  
Replaces the result of arbitration.

@param allocatableName  
Area or zone name.

@param contextName  
Context string of arbitration request.

@return  
The result of arbitration.

@details  
Replace allocated a content state to area or zone of the last arbitration result.  
If the allocatableName or contextName is undefined, return the errror code from the method getStatusType() of result.  
If the contextName is non-active, activate the content request.  
This API execute the "Request handling on lost" process and the "Execution expression" process, and doesn't execute the check of constraint expression process.  
Therefore, this API can lead the result that does not satisfy the constraints.  
If the specified area or zone by allocatableName is hidden, mute or attenuated, these statuses will be kept.

@deprecated  
Because there is a possibility that the result does not satisfy the constraints, please use execute() instead of this API.

**Example**  
```cpp
RBAJsonParser parser;  
rba::RBAModel* model = parser.parse(JSONFILE_PATH);  
rba::RBAArbitrator* arb = new rba::RBAArbitrator(model);  
std::unique_ptr\<RBAResult> result = arb->execute("CONTENT_A/NORMAL", true);  
std::unique_ptr\<RBAResult> result_replaced =  
	arb->setResultContentState("AREA_A", "CONTENT_B/NORMAL");

if (result_replaced->getStatusType() != rba::RBAResultStatusType::SUCCESS) {  
	std::cout << "ERROR" << std::endl;  
}  
```

**std::unique_ptr\<RBAResult> cancelArbitration();**  
@brief  
Cancel last arbitration.

@return  
The result of arbitration.

@details  
Cancel last arbitration and restore internal state immediately.  
This API returns the restored result but the ViewActions will be empty.  
Do not execute this function more than once continuously.  
In that case, an error occurs.  
Even when executed without performing arbitration processing, an error occurs.  
In case of error, the status of the arbitration result is set to CANCEL_ERROR.

**Example**  
```cpp
RBAJsonParser parser;  
rba::RBAModel* model = parser.parse(JSONFILE_PATH);  
rba::RBAArbitrator* arb = new rba::RBAArbitrator(model);  
std::unique_ptr\<RBAResult> result = arb->execute("CONTENT_A/NORMAL", true);  
std::unique_ptr\<RBAResult> result_back = arb->cancelArbitration();

if (result_replaced->getStatusType() != rba::RBAResultStatusType::SUCCESS) {  
	std::cout << "ERROR" << std::endl;  
}  
```

**void clearArbitration();**  
@brief  
Clear internal states of arbitration.

@details  
Initialize internal states of arbitration (ex. Previous arbitration result, request of content states, etc...) and set to the initial state.

@note  
This API is intended for setting up initial state of unit tests.

**Example**  
```cpp
std::unique_ptr\<RBAResult> result1 = arb->execute("CONTENT_A/NORMAL", true);  
std::unique_ptr\<RBAResult> result2 = arb->execute("CONTENT_B/NORMAL", true);  
// reset display requests  
arb->clearArbitration();  
std::unique_ptr\<RBAResult> result2 = arb->execute("CONTENT_C/NORMAL", true);  
std::unique_ptr\<RBAResult> result3 = arb->execute("CONTENT_D/NORMAL", true);  
```

**bool setScene(const std::string& sceneName, bool require, std::list<std::pair<std::string, std::int32_t>>& properties);**  
@brief  
Sets scene ON/OFF requests and properties.

@param sceneName  
The Scene name of arbitration reauest.

@param require  
true : Valid request  
false : Invalid request

@param properties  
The pair of property name and value.

@return  
true: Success  
false: Unknown scene

@details  
Sets the scene indicated by sceneName to the property specified by properties, and without execute arbitration processing.  
Returns true if the scene set succeeded.  
If an unknown scene name is specified, false is returned.

@note  
This API is intended for setting up initial state of unit tests or setting global scene and scene properties.

**Example**  
```cpp
std::list<std::pair<std::string, std::int32_t>> props;  
props.push_back(std::make_pair("PropertyA", 10);  
props.push_back(std::make_pair("PropertyB", -3);  
res = arb->setScene("SCENE_A", true, props);  
if (res == false) {  
	// Unknwon scene  
}  
```

**bool setContentState(const std::string& contextName, bool require);**  
@brief  
Sets content requests or scene ON/OFF request.

@param contextName  
Context string of arbitration request.

@param require  
true : request displaying / outputting content or scene on (default)  
false : withdraw a request or scene off.

@return  
true: Success  
false: Unknown context

@details  
Sets a display request for the context without arbitration.  
Returns true if the request setting is succeeded.  
If an unknown context name is specified, false is returned.

@note  
This API is intended for setting up initial state of unit tests.  
While initialize() has only the function to turn on the request, this API can turn off the request.  
It is used for switch of each requests when initialization setting of unit test.

**Example**  
```cpp
res = arb->setContentState("ContentA/NORMAL", true);  
if (res == false) {  
	// Unknwon context  
}  
```

**bool setAllocatableResult(const std::string& allocatableName, const std::string& contextName);**  
@brief  
Allocates content state to area or zone.

@param allocatableName  
Name of area or zone.

@param contextName  
Context string of content state.  
contextName : "<CONTENT_NAME>/<STATE_NAME>"  
If the content has only one state, the \<STATE> can be omitted.

@return  
true: Success  
false: Unknown area, zone or context

@details  
Allocates the content state to the area or zone.  
Arbitration and post arbitration will not be executed.  
The display / outputting request of the specified content state will be active.  
The statuses of hidden, mute and attenuated will not be changed.  
Returns true if the request setting is succeeded.  
If an unknown context name is specified, false is returned.

@note  
This API is intended for setting up initial state of unit tests.  
In setResultContentState(), in addition to content state assignment, evaluation of the action determination process at the time of arbitration losing and control execution expression is performed, whereas in this API only content state assignment is performed.

@deprecated  
Since there is a possibility of contradiction with the constraint, it is recommended not to use it except unit test.

**Example**  
```cpp
res = arb->setAllocatableResult("AreaA", "ContentA/NORMAL");  
if (res == false) {  
	// Unknwon area, zone or context  
}  
```

<div style="page-break-after:always"></div>
<a id="anchor3"></a>

# **4. Area class**

<span style="font-size:130%;">**4.1. Definition name**</span>  
<span style="font-size:130%;">DLL_EXPORT RBAArea</span>

<span style="font-size:130%;">**4.2. Overview**</span>  
<span style="font-size:130%;">Defines a Frame for displaying the view content.  
At run time, at most one view content is allocated to one area.</span>

<span style="font-size:130%;">**4.3. Class member**</span>  
**virtual std::string getName() const=0;**  
@brief  
Returns the name of the area.  

@return  
Area name.

**virtual std::int32_t getX() const=0;**  
@brief  
Returns the x-axis value of the base point of the area.

@return  
X-axis Value of the base point.

**virtual std::int32_t getY() const=0;**  
@brief  
Returns the y-axis value of the base point of the area.

@return  
Y-axis Value of the base point.

**virtual std::int32_t getZorder() const=0;**  
@brief  
Returns the z-order value.  
An area with a large z-order value is displayed on the front of an area with small z-order value.

@return  
Z-order value.

**virtual const std::list<const RBAViewContent\*>& getContents() const=0;**  
@brief  
Returns the list of content which can be displayed on this area.

@return  
List of content.

**virtual const std::list<const RBASize\*>& getSizes() const=0;**  
@brief  
Returns the list of size defined to this area.  
Since multiple size can be defined, returns a list of size.

@return  
List of size.

**virtual RBAArbitrationPolicy getArbitrationPolicy() const=0;**  
@brief  
Returns the arbitration policy value defined to this area.

@return  
Arbitration policy value.

<div style="page-break-after:always"></div>
<a id="anchor4"></a>

# **5. Base Point class**

<span style="font-size:130%;">**5.1. Definition name**</span>  
<span style="font-size:130%;">RBABasePoint : std::uint8_t</span>

<span style="font-size:130%;">**5.2. Overview**</span>  
<span style="font-size:130%;">Base point for object having size. For example Area.</span>

<span style="font-size:130%;">**5.3. Class member**</span>  
**LEFT_TOP**  
@brief  
Defines Left-Top coordinate as the base point of (x, y)  
The rectangle is represented by (x, y)-(x+width, y+height)

**LEFT_MIDDLE**  
@brief  
Defines Left-Middle coordinate as the base point of (x, y)  
The rectangle is represented by (x, y-height/2)-(x+width, y+height/2)

**LEFT_BOTTOM**  
@brief  
Defines Left-Bottom coordinate as the base point of (x, y)  
The rectangle is represented by (x, y-height)-(x+width, y)

**RIGHT_TOP**  
@brief  
Defines Right-Top coordinate as the base point of (x, y)  
The rectangle is represented by (x-width, y)-(x, y+height)

**RIGHT_MIDDLE**  
@brief  
Defines Right-Middle coordinate as the base point of (x, y)  
The rectangle is represented by (x-width, y-height/2)-(x, y+height/2)

**RIGHT_BOTTOM**  
@brief  
Defines Right-Bottom coordinate as the base point of (x, y)  
The rectangle is represented by (x-width, y-height)-(x, y)

**CENTER_TOP**  
@brief  
Defines Center-Top coordinate as the base point of (x, y)  
The rectangle is represented by (x-width/2, y)-(x+width/2, y+height)

**CENTER_MIDDLE**  
@brief  
Defines Center-Middle coordinate as the base point of (x, y)  
The rectangle is represented by (x-width/2, y-height/2)- (x+width/2, y+height/2)

**CENTER_BOTTOM**  
@brief  
Defines Center-Bottom coordinate as the base point of (x, y)  
The rectangle is represented by (x-width/2, y-height)-(x+width/2, y)

<div style="page-break-after:always"></div>
<a id="anchor5"></a>

# **6. Content Loser Type class**

<span style="font-size:130%;">**6.1. Definition name**</span>  
<span style="font-size:130%;">RBAContentLoserType : std::uint8_t</span>

<span style="font-size:130%;">**6.2. Overview**</span>  
<span style="font-size:130%;">Type of behavior when content loses the arbitration.</span>

<span style="font-size:130%;">**6.3. Class member**</span>  
**GOOD_LOSER=0**  
@brief  
Always cancels its request when losing arbitration.

**DO_NOT_GIVEUP_UNTIL_WIN**  
@brief  
Cancels its request only if it lost the arbitration in the displaying state.

**NEVER_GIVEUP**  
@brief  
Never cancels its request.

<div style="page-break-after:always"></div>
<a id="anchor6"></a>

# **7. Display class**

<span style="font-size:130%;">**7.1. Definition name**</span>  
<span style="font-size:130%;">RBADisplay</span>

<span style="font-size:130%;">**7.2. Overview**</span>  
<span style="font-size:130%;">Defines a screen layout of the display.  
You can define multiple displays for Multi-Display products.  
Display defines a set of areas which are laid out on it.</span>

<span style="font-size:130%;">**7.3. Class member**</span>  
**virtual std::string getName() const=0;**  
@brief  
Returns the name of display.

@return  
Display name.

**virtual const RBASize\* getSize() const=0;**  
@brief  
Returns the size of display.

@return  
Size

**virtual const std::list<const RBAArea\*>& getAreas() const=0;**  
@brief  
Returns areas which are allocated to the display.

@return  
List of area.

<div style="page-break-after:always"></div>
<a id="anchor7"></a>

# **8. Json Parser class**

<span style="font-size:130%;">**8.1. Definition name**</span>  
<span style="font-size:130%;">DLL_EXPORT RBAJsonParser</span>

<span style="font-size:130%;">**8.2. Overview**</span>  
<span style="font-size:130%;">Provides the facility that loads a model file in JSON format and generate a Model object.</span>

<span style="font-size:130%;">**8.3. Class member**</span>  
**RBAModel\* parse(const std::string& filename);**  
@brief  
Loads a JSON file and generates a model object.

@param filename  
Path of JSON file.

@return  
Model  
If the file is not found, returns nullptr.

**Example**  
```cpp
rba::RBAJsonParser parser;  
rba::RBAModel* model = parser.parse("RBAModel.json");  
if (model == nullptr) {  
	std::cout << "ERRROR: Could not read JSON file" << std::endl;  
	return 1;  
}  
rba::RBAArbitrator* arb = new rba::RBAArbitrator(model);
```

<div style="page-break-after:always"></div>
<a id="anchor8"></a>

# **9. Model class**

<span style="font-size:130%;">**9.1. Definition name**</span>  
<span style="font-size:130%;">DLL_EXPORT RBAModel</span>

<span style="font-size:130%;">**9.2. Overview**</span>  
<span style="font-size:130%;">Defines the arbitration rule model which is used by Arbitrator.  
The model consists of model elements such as areas, zones, contens, scenes, constraint expressions, and so on.  
Elements can be searched by name, and the list of elements for each type can be retrieved.</span>

<span style="font-size:130%;">**9.3. Class member**</span>  
**virtual const RBAArea\* findArea(const std::string& areaName) const=0;**  
@brief  
Search for area with a name.

@param areaName  
Area name.

@return  
Area

@details  
If the area name does not exist, returns nullptr.

**virtual const RBAViewContent\* findViewContent(const std::string& contName) const=0;**  
@brief  
Search for view content with a name.

@param contName  
Content name.

@return  
Content

@details  
If the content name does not exist, returns nullptr.

**virtual const RBAViewContentState\* findViewContentState(const std::string& stateName) const=0;**  
@brief  
Search for view content state with a name.

@param stateName  
Content state name.

@return  
State of view content.

@details  
If the content state name does not exist, returns nullptr.

**virtual const RBASize\* findSize(const std::string& sizeName) const=0;**  
@brief  
Search for size with a name.

@param sizeName  
Name of the search size.

@return  
Size

@details  
Specify the name of the search size as follows.  
In the case of the size linked to the area: <area_name>/<size_name>  
In the case of the size linked to the content: <content_name>/<size_name>  
If the name of the search size does not exist, returns nullptr.

**virtual const RBAZone\* findZone(const std::string& zoneName) const=0;**  
@brief  
Search for zone with a name.

@param zoneName  
Zone name.

@return  
Zone

@details  
If the zone name does not exist, returns nullptr.

**virtual const RBASoundContent\* findSoundContent(const std::string& contName) const=0;**  
@brief  
Search for sound content with a name.

@param stateName  
Content state name.

@return  
Sound content state.

@details  
If the content name does not exist, returns nullptr.

**virtual const RBASoundContentState\* findSoundContentState(const std::string& stateName) const=0;**  
@brief  
Search for sound content state with a name.

@param stateName  
Content state name.

@return  
Sound content state.

@details  
If the content state name does not exist, returns nullptr.

**virtual const RBAScene\* findScene(const std::string& sceneName) const=0;**  
@brief  
Search for scene with a name.

@param sceneName  
Scene name.

@return  
Scene

@details  
If the scene name does not exist, returns nullptr.

**virtual const RBADisplay\* findDisplay(const std::string& displayName) const=0;**  
@brief  
Search for display with a name.

@param displayName  
Display name.

@return  
Display

@details  
If the display name does not exist, returns nullptr.

**virtual const std::list<const RBAArea\*>& getAreas() const=0;**  
@brief  
Returns all the areas.

@return  
List of areas.

**virtual const std::list<const RBAViewContent\*>& getViewContents() const=0;**  
@brief  
Returns all the view contents.

@return  
List of contents.

**virtual const std::list<const RBAViewContentState\*>& getViewContentStates() const=0;**  
@brief  
Returns all the view content states.

@return  
List of view content states.

**virtual const std::list<const RBASize\*>& getSizes() const=0;**  
@brief  
Returns all the sizes.

@return  
List of sizes.

**virtual const std::list<const RBAZone\*>& getZones() const=0;**  
@brief  
Returns all the zones.

@return  
List of zones.

**virtual const std::list<const RBASoundContent\*>& getSoundContents() const=0;**  
@brief  
Returns all the sound contents.

@return  
List of sound contents.

**virtual const std::list<const RBASoundContentState\*>& getSoundContentStates() const=0;**  
@brief  
Returns all the sound content states.

@return  
List of sound content states.

**virtual const std::list<const RBAScene\*>& getScenes() const=0;**  
@brief  
Returns all the scenes.

@return  
List of scenes.

**virtual const std::list<const RBADisplay\*>& getDisplays() const=0;**  
@brief  
Returns all the displays.

@return  
List of displays.

**virtual const RBAModelElement\* findModelElement(const std::string& elementName) const=0;**  
@brief  
Search for Model element with a name.

@param elementName  
Model element name.

@return  
Model element.

@details  
If the Model element name does not exist, returns nullptr.

**virtual const std::list<const RBAAreaSet\*>& getAreaSets() const=0;**  
@brief  
Returns all the sets of areas.

@return  
List of sets of areas.

**virtual const std::list<const RBAViewContentSet\*>& getViewContentSets() const=0;**  
@brief  
Returns all the sets of view contents.

@return  
List of sets of view contents.

**virtual const std::list<const RBAPositionContainer\*>& getPositionContainers() const=0;**  
@brief  
Returns all the position containers.

@return  
List of sets of position containers.

**virtual std::list<RBAConstraint\*>& getConstraints()=0;**  
@brief  
Returns all the constraints.

@return  
List of constraints.

**virtual std::list<RBAPostConstraint\*>& getPostConstraints()=0;**  
@brief  
Returns all the post constraints.

@return  
List of post constraints.

<div style="page-break-after:always"></div>
<a id="anchor9"></a>

# **10. Position Container class**

<span style="font-size:130%;">**10.1. Definition name**</span>  
<span style="font-size:130%;">RBAPositionContainer</span>

<span style="font-size:130%;">**10.2. Overview**</span>  
<span style="font-size:130%;">Get the type and position of the area to be displayed.</span>

<span style="font-size:130%;">**10.3. Class member**</span>  
**virtual std::int32_t getX() const=0;**  
@brief  
Get X coordinate.

@return  
X coordinate value.

**virtual std::int32_t getY() const=0;**  
@brief  
Get Y coordinate.

@return  
Y coordinate value.

**virtual RBABasePoint getBasePoint() const=0;**  
@brief  
Get a base point.

@return  
Base point.

**virtual const RBAArea\* getArea() const=0;**  
@brief  
Get allocated area.

@return  
Assigned area.

**const static std::int32_t X_EDEFAULT=0;**  
@brief  
Default value of X coordinate.

**const static std::int32_t Y_EDEFAULT=0;**  
@brief  
Default value of Y coordinate.

**const static RBABasePoint BASE_POINT_EDEFAULT= RBABasePoint::LEFT_TOP;**  
@brief  
Base point default value.

<div style="page-break-after:always"></div>
<a id="anchor10"></a>

# **11. Result class**

<span style="font-size:130%;">**11.1. Definition name**</span>  
<span style="font-size:130%;">DLL_EXPORT RBAResult</span>

<span style="font-size:130%;">**11.2. Overview**</span>  
<span style="font-size:130%;">Stores an arbitration result.  
The Arbitrator allocates Contents to Areas.  
Related information of those can be acquired from RBAResult.  
The arbitration result indicates which content is allocated to each area / zone.  
Also, snapshot information and view action information (only display results) indicating the difference from the last arbitration are included.</span>

<span style="font-size:130%;">**11.3. Class member**</span>  
**virtual const std::list<const RBAArea\*>& getVisibleAreas() const=0;**  
@brief  
Returns the displaying areas determined by the last arbitration.

@return  
List of visible areas.

**virtual const std::list<const RBAZone\*>& getSoundingZones() const=0;**  
@brief  
Returns the outputting zones determined by the last arbitration.

@return  
List of sounding zones.

**virtual const std::list<const RBAViewContentState\*>& getVisibleContentStates() const=0;**  
@brief  
Returns the view content states to be displayed determined by the last arbitration.

@return  
List of visible view content states.

**virtual const std::list<const RBASoundContentState\*>& getSoundingContentStates() const=0;**  
@brief  
Returns the sound content states to be output determined by the last arbitration.

@return  
List of sound content states to be output.

@details  
The list contains sound contents to be attenuated.

**virtual const std::list<const RBAViewContentState\*>& getActiveViewContentStates() const=0;**  
@brief  
Returns the active view content states at the last arbitration result.

@return  
List of active view content states.

@details  
The active view content states are those that have been requested to display so far.  
They do not include the view content state whose request has been withdrawn or canceled.

**virtual const std::list<const RBASoundContentState\*>& getActiveSoundContentStates() const=0;**  
@brief  
Returns the active sound content states at the last arbitration result.

@return  
List of active sound content states.

@details  
The active sound content states are those that have been requested to output so far.  
They do not include the sound content state whose request has been withdrawn or canceled.

**virtual const std::list<const RBAScene\*>& getActiveScenes() const=0;**  
@brief  
Returns the active scenes at the last arbitration.

@return  
List of active scenes.

@details  
The active scenes are those that have been requested for ON so far.  
They do not include scenes requested for OFF afterwards.

**virtual const std::list<const RBAArea\*>& getInvisibleAreas() const=0;**  
@brief  
Returns the invisible areas determined by the last arbitration.

@return  
List of invisible areas.

@details  
Returns the areas which are not displayed out of all areas.  
The list contains areas to be hidden.

**virtual const std::list<const RBAZone\*>& getUnsoundingZones() const=0;**  
@brief  
Returns the unsounding zones determined by the last arbitration.

@return  
List of unsounding zones.

@details  
Returns the zones which are not output out of all zones.  
The list contains zones to be muted.

**virtual const std::list<const RBAArea\*>& getHiddenAreas() const=0;**  
@brief  
Returns the area that is hidden state and content has been allocated.

@return  
List of areas.

@details  
Returns the area which become to be invisible.  
The area invisible in the previous time is not included.  
The hidden state is a state in which the area must be hidden by a constraint expression.

**virtual const std::list<const RBAZone\*>& getMuteZones() const=0;**  
@brief  
Returns the zone that is muted state and content has been allocated.

@return  
List of muted zones.

@details  
Retuens the zones that is defeted and canceled sound contents.  
The muted state is a state in which the zone must be muted by a constraint expression.

**virtual const std::list<const RBAZone\*>& getAttenuatedZones() const=0;**  
@brief  
Returns the attenuated zones determined by the last arbitration.

@return  
List of attenuated zones.

**virtual const std::list<const RBAViewContent\*>& getCanceledViewContents() const=0;**  
@brief  
Returns the canceled view contents determined by the last arbitration.

@return  
List of canceled view contents.

@details  
Reterns list of view contents which are canceled by Request handling on lost definition such as Loser Type and Post Constraints.  
The list does not contain contents which are withdrawn.

**virtual const std::list<const RBASoundContent\*>& getCanceledSoundContents() const=0;**  
@brief  
Returns the canceled sound contents determined by the last arbitration.

@return  
List of canceled sound contents.

@details  
Reterns list of sound contents which are canceled by Request handling on lost definition such as Loser Type and Post Constraints.  
The list does not contain contents which are withdrawn.

**virtual const std::list<const RBAViewContent\*>& getStandbyViewContents() const=0;**  
@brief  
Returns the stand by view contents due to defeated at the last arbitration.

@return  
List of stand by view contents.

@details  
Returns list of view contents which are active but not allocated to any area.  
The list does not contains which are canceled contents or are allocated to hidden area.

**virtual const std::list<const RBASoundContent\*>& getStandbySoundContents() const=0;**  
@brief  
Returns the stand by sound contents due to defeated at the last arbitration.

@return  
List of stand by sound contents.

@details  
Returns list of sound contents which are active but not allocated to any area.  
The list does not contains which are canceled contents or are allocated to muted area.

**virtual const RBAViewContentState\* getContentState(const RBAArea\* area) const=0;**  
@brief  
Returns the view content state assigned to the area of the last arbitration.

@param area  
Area

@return  
The view content state assign to the area.

@details  
If no view content state is allocated to the area, nullptr is returnd.  
If area is not defined in the Model or nullptr, nullptr is returnd.

**virtual const RBASoundContentState\* getContentState(const RBAZone\* zone) const=0;**  
@brief  
Returns the sound content state assigned to the zone of the last arbitration.

@param zone  
Zone

@return  
The sound content state assign to the zone.

@details  
If no sound content state is allocated to the zone, nullptr is returned.  
If zone is not defined in the Model or nullptr, nullptr is returnd.

**virtual const std::list<const RBAArea\*> getArea(const RBAViewContentState\* state) const=0;**  
@brief  
Returns the area to which the view content state is allocated at the last arbitration.

@param state  
View content state.

@return  
The areas to which the view content state.

@details  
If the view content state is not assigned to any area, empty list is returned.  
If state is not defined in the Model or nullptr, empty list is returned.

**virtual const std::list<const RBAZone\*> getZone(const RBASoundContentState\* state) const=0;**  
@brief  
Get the zone to which the sound content state is allocated of the last arbitration.

@param state  
Sound content state.

@return  
The zones to which the sound content state is allocated.

@details  
If the sound content state is not assigned to any zone, empty list is retuened.  
If state is not defined in the Model or nullptr, empty list is returned.

**virtual const std::list<const RBAArea\*> getArea(const RBAViewContent\* content)const=0;**  
@brief  
Returns the area to which the view content is allocated of the last arbitration.

@param content  
View content.

@return  
The areas to which the view content is allocated.

@details  
If the view content is not assigned to any area, empty list is returned.  
If content is not defined in the Model or nullptr, empty list is returned.  
This API is the same as getArea(RBAViewContentState*) except for the type of argument.

**virtual const std::list<const RBAZone\*> getZone(const RBASoundContent\* content) const=0;**  
@brief  
Returns the zone to which the sound content state is allocated of the last arbitration.

@param content  
Sound content.

@return  
The zones to which the sound content is allocated.

@details  
If the sound content is not assigned to any area, nullptr is returned.  
If content is not defined in the Model or nullptr, empty list is returned.  
This API is the same as getZone(RBASoundContentState*) except for the type of argument.

**virtual const RBASize\* getSize(const RBAArea\* area) const=0;**  
@brief  
Returns the size of the area determined in the last arbitration.

@param area  
Area

@return  
The size of the area.

@details  
Area may have multiple sizes and its size will vary by the allocated content.  
This API returns the size which are matched with allocated content.  
If no content is allocated to the area, returns nullptr.  
If area is not defined in the Model or nullptr, returns nullptr.  
Returns nullptr if nullptr is specified for area.

**virtual bool isActive(const RBAScene\* scene) const=0;**  
@brief  
Returns true if the scene is ON at the last arbitration.

@param scene  
Reference scene to be checked.

@return  
true: the scene is ON  
false: the scene is OFF

@details  
If scene is not defined in the Model or nullptr, returns false.  
Returns false if nullptr is specified for scene.

**virtual bool isActive(const RBAViewContent\* content) const=0;**  
@brief  
Returns true if the view content is active.

@param state  
Reference view content to be checked.

@return  
true: Active  
false: Not active

@details  
If content is not defined in the Model or nullptr, returns false.  
Returns false if nullptr is specified for content.

**virtual bool isActive(const RBASoundContent\* content) const=0;**  
@brief  
Returns true if the sound content is active.

@param state  
Reference sound content to be checked.

@return  
true: Active  
false: Not active

@details  
If content is not defined in the Model or nullptr, returns false.  
Returns false if nullptr is specified for content.

**virtual bool isVisible(const RBAArea\* area) const=0;**  
@brief  
Returns true if the area is visible of the last arbitration.

@param area  
Reference area to be checked.

@return  
true: Visible  
false: Not visible

@details  
Returns false if the area is hidden.  
If area is not defined in the Model or nullptr, returns false.  
Returns false if nullptr is specified for area.

**virtual bool isSounding(const RBAZone\* zone) const=0;**  
@brief  
Returns true if the zone is sounding of the last arbitration.

@param zone  
Reference zone to be checked.

@return  
true: Sounding  
false: Not sounding

@details  
Returns false if the zone is muted.  
If zone is not defined in the Model or nullptr, returns false.  
Returns false if nullptr is specified for zone.

**virtual bool isVisible(const RBAViewContentState\* state) const=0;**  
@brief  
Returns true if the view content state is visible of the last arbitration.

@param state  
Reference view content state to be checked.

@return  
true: state is allocated to visible area.  
false: state is not allocated to visible area.

@details  
If all of the areas to which the content is allocated are hidden, returns false.  
If state is not defined in the Model or nullptr, returns false.  
Returns false if nullptr is specified for state.

**virtual bool isSounding(const RBASoundContentState\* state) const=0;**  
@brief  
Returns true if the sound content state is sounding of the last arbitration.

@param state  
Reference sound content state to be check.

@return  
true: state is allocated to outputting zone.  
false: state is not allocated to outputting zone.

@details  
If all of the zones to which the content is allocated are muted, returns false.  
If state is not defined in the Model or nullptr, returns false.  
Returns false if nullptr is specified for state.

**virtual const RBAViewContentState\* getViewContentState(const RBAArea\* area) const=0;**  
@brief  
Returns the view content state allocated to the area of the last arbitration.

@param area  
Area

@return  
The view content state allocated to the area.

@details  
Even if the area is hidden, Returns the allocated content state.  
If no visible view content state is allocated the area, nullptr is returnd.  
If area is not defined in the Model or nullptr, returns nullptr.  
Returns nullptr if nullptr is specified for area.

**virtual const RBASoundContentState\* getSoundContentState(const RBAZone\* zone) const=0;**  
@brief  
Returns the sounding sound content state assigned to the zone of the last arbitration.

@param zone  
Zone

@return  
The sounding sound content state assign to the zone.

@details  
Even if the zone is muted, Returns the allocated content state.  
If no sounding sound content state is allocated the area, nullptr is returnd.  
If zone is not defined in the Model or nullptr, returns nullptr.  
Returns nullptr if nullptr is specified for zone.

**virtual bool isHidden(const RBAArea\* area) const=0;**  
@brief  
Returns true if the area is hidden state of the last arbitration.

@param area  
Reference area to be checked.

@return  
true: Hidden  
false: Not hidden

@Details  
The hidden state is a state in which the area must be hidden by a constraint expression.  
In the hidden state, it returns true even if the content is not assigned.  
If area is not defined in the Model or nullptr, returns false.  
Returns false if nullptr is specified for area.

**virtual bool isMute(const RBAZone\* zone) const=0;**  
@brief  
Returns true if the zone is muted state of the last arbitration.

@param zone  
Reference zone to be checked.

@return  
true: Muted  
false: Not muted

@details  
The muted state is a state in which the zone must be muted by a constraint expression.  
In the muted state, it returns true even if the content is not assigned.  
If zone is not defined in the Model or nullptr, returns nullptr.  
Returns false if nullptr is specified for zone.

**virtual bool isAttenuated(const RBAZone\* zone) const=0;**  
@brief  
Returns true if the zone is attenuated of the last arbitration.

@param zone  
Reference zone to be check.

@return  
true: Attenuated  
false: Not attenuated

@details  
If zone is not defined in the Model or nullptr, returns nullptr.  
Returns false if nullptr is specified for zone.

**virtual bool isCancel(const RBAViewContentState\* state) const=0;**  
@brief  
Returns true if the view content state is canceled at the last arbitration.

@param state  
Reference view content state to be checked.

@return  
true: Canceled  
false: Not canceled or Not request view content state

@details  
If state is not active, returns false.  
If state is not defined in the Model or nullptr, returns false.  
Returns false if nullptr is specified for state.

**virtual bool isCancel(const RBASoundContentState\* state) const=0;**  
@brief  
Returns true if the sound content state is canceled at the last arbitration.

@param state  
Reference view content state to be checked.

@return  
true: Canceled  
false: Not canceled

@details  
If state is not active, returns false.  
If state is not defined in the Model or nullptr, returns false.  
Returns false if nullptr is specified for state.

**virtual const std::list<const RBAViewAction\*>& getViewActions() const=0;**  
@brief  
Returns information of view status changes (the view actions) of the last arbitration.

@return  
List of view actions.

@details  
ViewAction is an information of differences between the last arbitration result and its previous result.  
There is no difference between hidden and not displayed for visible status.

**virtual RBAResultStatusType getStatusType() const=0;**  
@brief  
Returns the result status type of the last arbitration.

@return  
SUCCESS: Success  
UNKNOWN_CONTENT_STATE: Failed (The reuqest is unknown)  
CANCEL_ERROR: Cancel arbitrration error

**virtual bool satisfiesConstraints() const=0;**  
@brief  
Returns satisfied status of all online constraints.

@return  
true: All online constraints check result is OK, and arbitration finished.  
false: All online constraints check result is NG, and arbitration finished.

**virtual std::int32_t getSceneProperty(const RBAScene\* scene, const std::string& propertyName) const=0;**  
@brief  
Returns the property value of scene.

@return  
Property value.

@details  
If the scene or propertyName is not defined in the Model, returns -99.  
Returns -99 if a property name not defined in the model is specified in propertyName.

**virtual const std::list<const RBAArea\*>& getPreVisibleAreas() const=0;**  
@brief  
Returns the displaying areas of the previous arbitration.

@return  
List of visible areas.

**virtual const std::list<const RBAZone\*>& getPreSoundingZones() const=0;**  
@brief  
Returns the outputting sounding zones of the previous arbitration.

@return  
List of sounding zones.

**virtual const std::list<const RBAViewContentState\*>& getPreVisibleContentStates() const=0;**  
@brief  
Returns the view content states to be displayed of the previous arbitration.

@return  
List of visible view content states.

**virtual const std::list<const RBASoundContentState\*>& getPreSoundingContentStates() const=0;**  
@brief  
Returns the sound content states to be outputted of the previous arbitration.

@return  
List of sounding sound content states.

@details  
The list contains attenuated content states.

**virtual const std::list<const RBAViewContentState\*>& getPreActiveViewContentStates() const=0;**  
@brief  
Returns the active view content states of the previous arbitration result.

@return  
List of active view content states.

@details  
The active view content states are those that have been requested to display so far.  
They do not include the view content state whose request has been withdrawn or canceled.

**virtual const std::list<const RBASoundContentState\*>& getPreActiveSoundContentStates() const=0;**  
@brief  
Returns the active sound content states of the previous arbitration result.

@return  
List of active sound content states.

@details  
The active sound content states are those that have been requested to output so far.  
They do not include the sound content state whose request has been withdrawn or canceled.

**virtual const std::list<const RBAScene\*>& getPreActiveScenes() const=0;**  
@brief  
Returns the active scenes of the previous arbitration.

@return  
List of active scenes.

@details  
The active scenes are those that have been requested for ON so far.  
They do not include scenes requested for OFF afterwards.

**virtual const std::list<const RBAArea\*>& getPreInvisibleAreas() const=0;**  
@brief  
Returns the invisible areas of the previous arbitration.

@return  
List of invisible areas.

@details  
Returns the areas which are not displayed out of all areas.  
The hidden area is also acquired.

**virtual const std::list<const RBAZone\*>& getPreUnsoundingZones() const=0;**  
@brief  
Returns the unsounding zones of the previous arbitration.

@return  
List of unsounding zones.

@details  
Returns the zones which are not outputted out of all zones.  
Muted zones are also acquired.

**virtual const std::list<const RBAArea\*>& getPreHiddenAreas() const=0;**  
@brief  
Returns the areas which have become invisible at the previous arbitration.

@return  
List of areas.

@details  
Returns the area which become to be invisible.

**virtual const std::list<const RBAZone\*>& getPreMuteZones() const=0;**  
@brief  
Get the muted zones of the previous arbitration.

@return  
List of muted zones.

@details  
Retuens the zones that is defeted and canceled sound contents.

**virtual const std::list<const RBAZone\*>& getPreAttenuatedZones() const=0;**  
@brief  
Returns the attenuated zones of the previous arbitration.

@return  
List of attenuated zones.

**virtual const std::list<const RBAViewContent\*>& getPreCanceledViewContents() const=0;**  
@brief  
Returns the canceled view contents of the previous arbitration.

@return  
List of canceled view contents.

@details  
In the previous arbitration process, the display content that has been canceled by the losing action is acquired.  
Due to the display withdrawal request, those for which the display request has been withdrawn are not acquired.

**virtual const std::list<const RBASoundContent\*>& getPreCanceledSoundContents() const=0;**  
@brief  
Returns the canceled sound contents of the previous arbitration.

@return  
List of canceled sound contents.

@details  
In the previous arbitration process, the voice content that has been canceled by the losing action is acquired.  
A request whose output request has been withdrawn by the output withdrawal request is not acquired.

**virtual const std::list<const RBAViewContent\*>& getPreStandbyViewContents() const=0;**  
@brief  
Returns the stand by view contents due to defeated at the previous arbitration.

@return  
List of stand by view contents.

@details  
There is a display request, and the display content that has not been allocated to the area is acquired.  
Due to the losing action, the display content whose request has been canceled or the display content which has been allocated to the area but has the area hidden is not obtained.

**virtual const std::list<const RBASoundContent\*>& getPreStandbySoundContents() const=0;**  
@brief  
Returns the stand by sound contents due to defeated at previous arbitration.

@return  
List of stand by sound contents.

@details  
There is an output request, and the audio content not assigned to the zone is acquired.  
Due to the losing action, the audio content whose request has been canceled or the audio content assigned to the zone but the zone has been muted are not obtained.

**virtual const RBAViewContentState\* getPreContentState(const RBAArea\* area) const=0;**  
@brief  
Returns the view content state assigned to the area of the previous arbitration.

@param area  
Area

@return  
The view content state assign to the area.

@details  
If no view content state is allocated to the area, nullptr is returnd.  
If an area that is not defined in the model set in the arbitration FW that has performed arbitration processing is specified, nullptr is returned.  
If nullptr is specified in area, nullptr is returned.

**virtual const RBASoundContentState\* getPreContentState(const RBAZone\* zone) const=0;**  
@brief  
Returns the sound content state assigned to the zone of the previous arbitration.

@param zone  
Zone

@return  
The sound content state assign to the zone.

@details  
If no sound content state is allocated to the zone, nullptr is returned.  
If a zone that is not defined in the model set in the arbitration FW that has performed arbitration processing is specified, nullptr is returned.  
If nullptr is specified in zone, nullptr is returned.

**virtual const std::list<const RBAArea\*> getPreArea(const RBAViewContentState\* state) const=0;**  
@brief  
Returns the area to which the view content state is allocated of the previous arbitration.

@param state  
View content state.

@return  
The areas to which the view content state.

@details  
If no display content state has been assigned to the area, an empty list is returned.  
If a state that is not defined in the model set in the arbitration FW that has performed arbitration processing is specified, an empty list is returned.  
If nullptr is specified for state, an empty list is returned.

**virtual const std::list<const RBAZone\*> getPreZone(const RBASoundContentState\* state) const=0;**  
@brief  
Get the zone to which the sound content state is allocated of the previous arbitration.

@param state  
Sound content state.

@return  
The zones to which the sound content state is allocated.

@details  
Returns an empty list if no audio content state has been assigned to the zone.  
If a state that is not defined in the model set in the arbitration FW that has performed arbitration processing is specified, an empty list is returned.  
If nullptr is specified for state, an empty list is returned.

**virtual const std::list<const RBAArea\*> getPreArea(const RBAViewContent\* content) const=0;**  
@brief  
Returns the area to which the view content is allocated of the previous arbitration.

@param content  
View content.

@return  
The areas to which the view content is allocated.

@details  
If no display content has been assigned to the area, an empty list is returned.  
If content that has no definition is specified in the model set in the arbitration FW that has performed arbitration processing, an empty list is returned.  
If nullptr is specified for content, an empty list is returned.  
The only difference from getArea (RBAViewContentState *) is the type of the argument. If the request is for the same content, the return value always matches.

**virtual const std::list<const RBAZone\*> getPreZone(const RBASoundContent\* content) const=0;**  
@brief  
Returns the zone to which the sound content state is allocated of the previous arbitration.

@param content  
Sound content.

@return  
The zones to which the sound content is allocated.

@details  
If no audio content has been assigned to the zone, return an empty list.  
If content that has no definition is specified in the model set in the arbitration FW that has performed arbitration processing, an empty list is returned.  
If nullptr is specified for content, an empty list is returned.  
The only difference from getZone (RBASoundContentState *) is the type of the argument. If the request is for the same content, the return value always matches.

**virtual const RBASize\* getPreSize(const RBAArea\* area) const=0;**  
@brief  
Returns the size of the area determined in the previous arbitration.

@param area  
Area

@return  
The size of the area.

@details  
A plurality of sizes can be defined for the area, and the size changes according to the display content.  
Respond the size according to the display content allocated to the area.  
Returns nullptr if no display content has been assigned to the area.  
If an area that is not defined in the model set in the arbitration FW that has performed arbitration processing is specified, nullptr is returned.  
If nullptr is specified in area, nullptr is returned.

**virtual bool isPreActive(const RBAScene\* scene) const=0;**  
@brief  
Returns true if the scene is active of the previous arbitration.

@param scene  
Reference scene to be checked.

@return  
true: Active  
false: Not active

@details  
The active scene is the scene requested to ON.  
If a scene with no definition in the model set in the arbitration FW that has performed the arbitration process is specified, false is returned.  
Returns false if nullptr is specified in scene.

**virtual bool isPreActive(const RBAViewContent\* content) const=0;**  
@brief  
Returns true if the view content is active of the previous arbitration.

@param state  
Reference view content to be checked.

@return  
true: Active  
false: Not active

@details  
The active view content is the content requested to be displayed.  
If a display content with no definition in the model set in the arbitration FW that performed the arbitration process is specified, false is returned.  
Returns false if nullptr is specified for content.

**virtual bool isPreActive(const RBASoundContent\* content) const=0;**  
@brief  
Returns true if the sound content is active of the previous arbitration.

@param state  
Reference sound content to be checked.

@return  
true: Active  
false: Not active

@details  
The active sound content is the content requested to be outputted.  
If an audio content that is not defined in the model set in the arbitration FW that has performed arbitration processing is specified, false is returned.  
Returns false if nullptr is specified for content.

**virtual bool isPreVisible(const RBAArea\* area) const=0;**  
@brief  
Returns true if the area is visible of the previous arbitration.

@param area  
Reference area to be checked.

@return  
true: Visible  
false: Not visible

@details  
The concealed area returns false.  
If an area that is not defined in the model set in the arbitration FW that has performed arbitration processing is specified, false is returned.  
Returns false if nullptr is specified for area.

**virtual bool isPreSounding(const RBAZone\* zone) const=0;**  
@brief  
Returns true if the zone is sounding of the previous arbitration.

@param zone  
Reference zone to be checked.

@return  
true: Sounding  
false: Not sounding

@details  
Areas that have been muted return false.  
If a zone that is not defined in the model set in the arbitration FW that performed the arbitration process is specified, false is returned.  
Returns false if nullptr is specified in zone.

**virtual bool isPreVisible(const RBAViewContentState\* state) const=0;**  
@brief  
Returns true if the view content state is visible of the previous arbitration.

@param state  
Reference view content state to be checked.

@return  
true: state is allocated to visible area.  
false: state is not allocated to visible area.

@details  
Returns false if it is only assigned to a hidden area.  
If an area that is not defined in the model set in the arbitration FW that has performed arbitration processing is specified, false is returned.  
Returns false if nullptr is specified for state.

**virtual bool isPreSounding(const RBASoundContentState\* state) const=0;**  
@brief  
Returns true if the sound content state is sounding of the previous arbitration.

@param state  
Reference sound content state to check.

@return  
true: state is allocated to outputting zone.  
false: state is not allocated to outputting zone.

@details  
Returns false if assigned only to a muted zone.  
If a state that is not defined in the model set in the arbitration FW that performed the arbitration process is specified, false is returned.  
Returns false if nullptr is specified for state.

**virtual const RBASoundContentState\* getPreSoundContentState(const RBAZone\* zone) const=0;**  
@brief  
Returns the sounding sound content state assigned to the zone of the previous arbitration.

@param zone  
Zone

@return  
The sounding sound content state assign to the zone.

@details  
When a zone is muted, Returns the content state.  
If no sounding sound content state is allocated the area, nullptr is returnd.  
If a zone that is not defined in the model set in the arbitration FW that has performed arbitration processing is specified, nullptr is returned.  
If nullptr is specified in zone, nullptr is returned.

**virtual bool isPreHidden(const RBAArea\* area) const=0;**  
@brief  
Returns true if the area is hidden of the previous arbitration.

@param area  
Reference area to be checked.

@return  
true: Hidden  
false: Not hidden

@details  
If an area that is not defined in the model set in the arbitration FW that has performed arbitration processing is specified, false is returned.  
Returns false if nullptr is specified for area.

**virtual bool isPreMute(const RBAZone\* zone) const=0;**  
@brief  
Returns true if the zone is muted of the previous arbitration.

@param zone  
Reference zone to be checked.

@return  
true: Muted  
false: Not muted

@details  
If a zone that is not defined in the model set in the arbitration FW that performed the arbitration process is specified, false is returned.  
Returns false if nullptr is specified in zone.

**virtual bool isPreAttenuated(const RBAZone\* zone) const=0;**  
@brief  
Returns true if the zone is attenuated of the previous arbitration.

@param zone  
Reference zone to be checked.

@return  
true: Attenuated  
false: Not attenuated

@details  
If a zone that is not defined in the model set in the arbitration FW that performed the arbitration process is specified, false is returned.  
Returns false if nullptr is specified in zone.

**virtual bool isPreCancel(const RBAViewContentState\* state) const=0;**  
@brief  
Returns true if the view content state is canceled of the previous arbitration.

@param state  
Reference view content state to be checked.

@return  
true: Canceled  
false: Not canceled or Not request view content state

@details  
If the display content state for which there was no display request before the arbitration process is specified in state, false is returned.  
If a state that is not defined in the model set in the arbitration FW that performed the arbitration process is specified, false is returned.  
Returns false if nullptr is specified for state.

**virtual bool isPreCancel(const RBASoundContentState\* state) const=0;**  
@brief  
Returns true if the sound content state is canceled of the previous arbitration.

@param state  
Reference view content state to be checked.

@return  
true: Canceled  
false: Not canceled

@details  
If the audio content state for which no output request was made before the arbitration process is specified in state, false is returned.  
If a state that is not defined in the model set in the arbitration FW that performed the arbitration process is specified, false is returned.  
Returns false if nullptr is specified for state.

**virtual std::string getLog() const=0;**  
@brief  
Returns the log of the last arbitration.

@return  
Log string.

**virtual bool hasDisplayingArea(const RBADisplay\* display) const=0;**  
@brief  
Get the display state of the display.

@param display  
Display to check.

@return  
true: Something is displayed  
false: Nothing is displayed

<div style="page-break-after:always"></div>
<a id="anchor11"></a>

# **12. Arbitration Result Status Type class**

<span style="font-size:130%;">**12.1. Definition name**</span>  
<span style="font-size:130%;">RBAResultStatusType : std::uint8_t</span>

<span style="font-size:130%;">**12.2. Overview**</span>  
<span style="font-size:130%;">Status of the arbitration result.</span>

<span style="font-size:130%;">**12.3. Class member**</span>  
**SUCCESS**  
@brief  
Success

**FAILED**  
@brief  
Failed

**UNKNOWN_CONTENT_STATE**  
@brief  
Unknown context or content state.

**CANCEL_ERROR**  
@brief  
Cancel arbitration error.

<div style="page-break-after:always"></div>
<a id="anchor12"></a>

# **13. Scene class**

<span style="font-size:130%;">**13.1. Definition name**</span>  
<span style="font-size:130%;">RBAScene</span>

<span style="font-size:130%;">**13.2. Overview**</span>  
<span style="font-size:130%;">Express the state(Including system state) at that time comprehensively.  
Used scene for switch area/zone and view/sound content state.  
And plural RBA model(project) can share arbitration result by definitions global scene.</span>

<span style="font-size:130%;">**13.3. Class member**</span>  
**virtual std::string getName() const=0;**  
@brief  
Returns the scene name.

@return  
Scene name.

**virtual bool isGlobal() const=0;**  
@brief  
Returns the global scene status.

@return  
Global scene status.

**virtual const std::list\<std::string>& getPropertyNames() const=0;**  
@brief  
Returns List of the scene property name.

@return  
List of the scene property name.

**virtual std::int32_t getPropertyValue(const std::string& propertyName) const=0;**  
@brief  
Returns Default value of the scene property.

@param propertyName  
Scene property name.

@return  
Default value of the scene property.

<div style="page-break-after:always"></div>
<a id="anchor13"></a>

# **14. Size class**

<span style="font-size:130%;">**14.1. Definition name**</span>  
<span style="font-size:130%;">DLL_EXPORT RBASize</span>

<span style="font-size:130%;">**14.2. Overview**</span>  
<span style="font-size:130%;">Size definitions for object such as areas or view contents.  
Each object can define plural size.  
Can refer to size from object.</span>

<span style="font-size:130%;">**14.3. Class member**</span>  
**virtual std::string getName() const=0;**  
@brief  
Returns the name of the size.

@return  
Size name.

**virtual std::int32_t getWidth() const=0;**  
@brief  
Returns the width of the size.

@return  
Width of the size.

**virtual std::int32_t getHeight() const=0;**  
@brief  
Returns the height of the size.

@return  
Height of the size.

**const static std::int32_t WIDTH_EDEFAULT = 0;**  
@brief  
Default width of size.

**const static std::int32_t HEIGHT_EDEFAULT = 0;**  
@brief  
Default height of size.

<div style="page-break-after:always"></div>
<a id="anchor14"></a>

# **15. Sound Content class**

<span style="font-size:130%;">**15.1. Definition name**</span>  
<span style="font-size:130%;">DLL_EXPORT RBASoundContent</span>

<span style="font-size:130%;">**15.2. Overview**</span>  
<span style="font-size:130%;">Define the object of sound content.  
Sound content has plural status.  
When sound contents connected to a zone, active status is output.  
Object has zone definitions, that can output itself.  
Each object can define plural zone which can output sound contents.</span>

<span style="font-size:130%;">**15.3. Class member**</span>  
**virtual std::string getName() const=0;**  
@brief  
Returns the name of the sound content.

@return  
Sound content name.

**virtual const std::list<const RBASoundContentState\*>& getContentStates() const=0;**  
@brief  
Returns the state of the sound content.

@return  
List of the sound content state.

**virtual const std::list<const RBAZone\*>& getZones() const=0;**  
@brief  
Returns the zone of the sound content.

@return  
List of the zone.

**virtual RBAContentLoserType getLoserType() const=0;**  
@brief  
Returns the loser type.

@return  
Loser type.

**const static RBAContentLoserType LOSER_TYPE_EDEFAULT = RBAContentLoserType::NEVER_GIVEUP;**  
@brief  
Defines the default loser type.

<div style="page-break-after:always"></div>
<a id="anchor15"></a>

# **16. Sound Content State class**

<span style="font-size:130%;">**16.1. Definition name**</span>  
<span style="font-size:130%;">DLL_EXPORT RBASoundContentState</span>

<span style="font-size:130%;">**16.2. Overview**</span>  
<span style="font-size:130%;">Define the state of sound contents.</span>

<span style="font-size:130%;">**16.3. Class member**</span>  
**virtual std::string getName() const=0;**  
@brief  
Returns the name of the sound contents state.

@return  
Sound contents state name.

**virtual std::int32_t getPriority() const=0;**  
@brief  
Returns the priority.

@return  
Priority value.

**virtual const RBASoundContent\* getOwner() const=0;**  
@brief  
Returns the sound content.

@return  
Sound content.

**virtual std::int32_t getOrder() const=0;**  
@brief  
Returns the order.

@return  
Order value.

@details  
The order is a number of sequence of the entry sound content state by request.  
The order value is an integer value starting from 1 and incremented in order, and the order value of the sound content state without sound request is set to 0.
The order of the sound content state does not include the output request of the view content state.

**virtual std::string getUniqueName() const=0;**  
@brief  
Returns the unique character string of the sound contents state.

@return  
Unique character string of the sound contents state.

@details  
Unique character string is sound content name + CONTEXT_SEPARATER + sound content state name.  
Use the unique character string as a context name.

**static std::string getContentNameByContext(const std::string& context);**  
@brief  
Returns the name of the sound content from context name.

@param context  
The context name.

@return  
Name of the sound content.

**static std::string getContentStateNameByContext(const std::string& context);**  
@brief  
Returns the state of the sound content from context name.

@param context  
The context name.

@return  
State of the sound content.

**static bool isUniqueName(const std::string& context);**  
@brief  
Check if argument is The unique character string(context name).

@param context  
The context name.

@return  
true: unique character string(context name)  
false: Not unique character string(context name)

**const static std::int32_t PRIORITY_EDEFAULT = 0;**  
@brief  
Defines the default priority value.

**const static char CONTEXT_SEPARATER = '/';**  
@brief  
Defines the separator for separating sound content name and sound content state name.  
And be the character to connect it.

<div style="page-break-after:always"></div>
<a id="anchor16"></a>

# **17. View Action class**

<span style="font-size:130%;">**17.1. Definition name**</span>  
<span style="font-size:130%;">DLL_EXPORT RBAViewAction</span>

<span style="font-size:130%;">**17.2. Overview**</span>  
<span style="font-size:130%;">Define the change information of view contents.  
Change information has 2 type.  
The contents transition, that view contents change for an area.  
The contents move, that the view content displayed area changes.</span>

<span style="font-size:130%;">**17.3. Class member**</span>  
**virtual const RBAArea\* getArea() const;**  
@brief  
Returns the area of the contents transition.

@return  
Area of the contents transition.

**virtual const RBAViewContent\* getFromContent() const;**  
@brief  
Returns previously displayed the view content.  
Used when change information type is the contents transition(TRANSITION_REPLACE).

@return  
Previously displayed the view content.

@details  
If the change information type is not the contents transition(TRANSITION_REPLACE), returns nullptr.

**virtual const RBAViewContent\* getToContent() const;**  
@brief  
Returns subsequently displayed the view content.  
Used when change information type is the contents transition(TRANSITION_REPLACE).

@return  
Subsequently displayed the view content.

@details  
If the change information type is not the contents transition(TRANSITION_REPLACE), returns nullptr.

**virtual const RBAViewContentState\* getFromContentState() const;**  
@brief  
Returns previously displayed the view content state.  
Used when change information type is the contents transition(TRANSITION_REPLACE).

@return  
Previously displayed the view content state.

@details  
If the change information type is not the contents transition(TRANSITION_REPLACE), returns nullptr.

**virtual const RBAViewContentState\* getToContentState() const;**  
@brief  
Returns subsequently displayed the view content state.
Used when change information type is the contents transition(TRANSITION_REPLACE).

@return  
Subsequently displayed the view content state.

@details  
If the change information type is not the contents transition(TRANSITION_REPLACE), returns nullptr.

**virtual const RBAArea\* getFromArea() const;**  
@brief  
Returns previously displayed the area.  
Used when change information type is the contents move(MOVE).  
@return  
Previously displayed the area.

@details  
If the change information type is not the contents move(MOVE), returns nullptr.

**virtual const RBAArea\* getToArea() const;**  
@brief  
Returns subsequently displayed the area.  
Used when change information type is the contents move(MOVE).

@return  
Subsequently displayed the area.

@details  
If the change information type is not the contents move(MOVE), returns nullptr.

**virtual const RBAViewContent\* getContent() const;**  
@brief  
Returns view content of change information.

@return  
View content of change information.

@details  
If getViewActionType() == TRANSITION_ADD, returns display view content.  
If getViewActionType() == TRANSITION_REMOVE, returns hide view content.  
If getViewActionType() == TRANSITION_REPLACE, returns nullptr.  
If getViewActionType() == MOVE, returns view content which changes the area.

**virtual const RBAViewContentState\* getContentState() const;**  
@brief  
Returns view content state of change information.

@return  
View content state of change information.

@details  
If getViewActionType() == TRANSITION_ADD, returns display view content state.  
If getViewActionType() == TRANSITION_REMOVE, returns hide view content state.  
If getViewActionType() == TRANSITION_REPLACE, returns nullptr.  
If getViewActionType() == MOVE, returns view content state which changes the area.

**virtual RBAViewActionType getViewActionType() const=0;**  
@brief  
Returns view action type.

@return  
View action type.

**virtual bool operator==(const RBAViewAction& viewAction)=0;**  
@brief  
Equal operator.

@return  
true: equal  
false: not equal

<div style="page-break-after:always"></div>
<a id="anchor17"></a>

# **18. View Action Type class**

<span style="font-size:130%;">**18.1. Definition name**</span>  
<span style="font-size:130%;">RBAViewActionType : std::uint8_t</span>

<span style="font-size:130%;">**18.2. Overview**</span>  
<span style="font-size:130%;">Indicates the type of view action.</span>

<span style="font-size:130%;">**18.3. Class member**</span>  
**TRANSITION_ADD**  
@brief  
The content transition(ADD) : content is displayed in the area.

**TRANSITION_REMOVE**  
@brief  
The content transition(REMOVE) : content is deleted from the area.

**TRANSITION_REPLACE**  
@brief  
The content transition(REPLACE) : content is replaced on the area.

**MOVE**  
@brief  
The content move(MOVE) : The display of content changes to another area.

<div style="page-break-after:always"></div>
<a id="anchor18"></a>

# **19. View Content class**

<span style="font-size:130%;">**19.1. Definition name**</span>  
<span style="font-size:130%;">RBAViewContent</span>

<span style="font-size:130%;">**19.2. Overview**</span>  
<span style="font-size:130%;">Define the object of view content.  
View content has plural status.  
When view contents connected to a area, active status is displayed.  
Each object can define plural area which can displayed view contents.</span>

<span style="font-size:130%;">**19.3. Class member**</span>  
**virtual std::string getName() const=0;**  
@brief  
Returns the name of the view content.

@return  
View content name.

**virtual const std::list<const RBAViewContentState\*>& getContentStates() const=0;**  
@brief  
Returns the state of the view content.

@return  
List of view content state.

**virtual const std::list<const RBAArea\*>& getAreas() const=0;**  
@brief  
Returns the area of the view content.

@return  
List of the area.

**virtual const std::list<const RBASize\*>& getSizes() const=0;**  
@brief  
Returns the list of size assignment to this content.

@return  
List of size.

**virtual RBAContentLoserType getLoserType() const=0;**  
@brief  
Returns the loser type.

@return  
Loser type.

**const static RBAContentLoserType LOSER_TYPE_EDEFAULT = 
RBAContentLoserType::NEVER_GIVEUP;**  
@brief  
Defines the default loser type.

<div style="page-break-after:always"></div>
<a id="anchor19"></a>

# **20. View Content State class**

<span style="font-size:130%;">**20.1. Definition name**</span>  
<span style="font-size:130%;">DLL_EXPORT RBAViewContentState</span>

<span style="font-size:130%;">**20.2. Overview**</span>  
<span style="font-size:130%;">Define the state of view contents.</span>

<span style="font-size:130%;">**20.3. Class member**</span>  
**virtual std::string getName() const=0;**  
@brief  
Returns the name of the view contents state.

@return  
View contents state name.

**virtual std::int32_t getPriority() const=0;**  
@brief  
Returns the priority.

@return  
Priority value.

**virtual const RBAViewContent\* getOwner() const=0;**  
@brief  
Returns the view content.

@return  
View content.

**virtual std::int32_t getOrder() const=0;**  
@brief  
Returns the order.

@return  
Order value.

@details  
The order is a number of sequence of the entry view content state by request.  
The order value is an integer value starting from 1 and incremented in order, and the order value of the view content state without view request is set to 0.  
The order of the view content state does not include the output request of the sound content state.

**virtual std::string getUniqueName() const=0;**  
@brief  
Returns the unique character string of the view contents state.

@return  
Unique character string of the view contents state.

@details  
Unique character string is view content name + CONTEXT_SEPARATER + view content state name.  
Use the unique character string as a context name.

**static std::string getContentNameByContext(const std::string& context);**  
@brief  
Returns the name of the view content from context name.

@param context  
The context name.

@return  
Name of the view content.

**static std::string getContentStateNameByContext(const std::string& context);**  
@brief  
Returns the state of the view content from context name.

@param context  
The context name.

@return  
State of the view content.

**static bool isUniqueName(const std::string& context);**  
@brief  
Check if argument is The unique character string(context name).

@param context  
The context name.

@return  
true: unique character string(context name)  
false: Not unique character string(context name)

**const static std::int32_t PRIORITY_EDEFAULT = 0;**  
@brief  
Defines the default priority value.

**const static char CONTEXT_SEPARATER = '/';**  
@brief  
Defines the separator for separating view content name and view content state name.  
And be the character to connect it.

<div style="page-break-after:always"></div>
<a id="anchor20"></a>

# **21. Zone class**

<span style="font-size:130%;">**21.1. Definition name**</span>  
<span style="font-size:130%;">DLL_EXPORT RBAZone</span>

<span style="font-size:130%;">**21.2. Overview**</span>  
<span style="font-size:130%;">Defines a Frame for outputting sound content.  
At run time, at most one sound content is allocated to one zone.  
This class has arbitration policy definitions, because it is executed for each zone.</span>

<span style="font-size:130%;">**21.3. Class member**</span>  
**virtual std::string getName() const=0;**  
@brief  
Returns the name of the zone.

@return  
Zone name.

**virtual std::int32_t getPriority() const=0;**  
@brief  
Returns the priority.

@return  
Priority value.

**virtual const std::list<const RBASoundContent\*>& getContents() const=0;**  
@brief  
Returns the list of content which can be output in this zone.

@return  
List of content.

**virtual RBAArbitrationPolicy getArbitrationPolicy() const=0;**  
@brief  
Returns the arbitration policy value defined to this zone.

@return 
Arbitration policy value.
